# CRI Middleware 製ファイルのバイナリフォーマット

CRI Middleware のフォーマットは広く知られたフォーマットではないものの、広く日本のゲームでは使われているため解析も多くすすんでいる。

デレステでは音声まわりで CRI のツールを利用している。

すでにあるものとしては [DereTore](https://github.com/OpenCGSS/DereTore) のコードが網羅的で整っており参考になる。ただ C# 実装なので若干遅い。

## ファイル構造について

ACB、AWB、ACB とファイル形式が存在する。ACB の中に AWB が入っており、AWB の中に HCA が入っているという構造になっている。なお ACB は内部に AWB を含めるだけでなく、外部の AWB を参照することができる。

ACB には汎用的なテーブルを格納することができる。AWB はインデックスとバイナリの連想配列になっている。HCA は音声の生データになる。

すなわち、ACB に格納されているメタデータを参照しつつ、必要な HCA を取り出すという形をとる。

## ACB ファイルのフォーマット

ACB ファイルは @UTF という形式を用いている。数値はビッグエンディアンである。

### ファイルヘッダ

```
0x0000 | 40 55 54 46 | 固定（'@UTF'）
0x0004 | 00 39 02 78 | ファイルのファイルヘッダを除いたサイズ（すなわちファイルサイズ−8）
```

### テーブルヘッダ

ここからがテーブルの内容で、すべてのオフセット値などはここから計算する。

```
0x0000 | 00 01       | 不明（バージョン?）
0x0002 | 01 58       | テーブルデータのオフセット
0x0004 | 00 00 02 8D | 文字列データのオフセット
0x0008 | 00 00 05 B8 | バイナリデータのオフセット
0x000c | 00 00 00 00 | テーブル名の文字列オフセット
0x0010 | 00 40       | 列（カラム）の数
0x0012 | 01 35       | 各行あたりのバイト数（定数値除く）
0x0014 | 00 00 00 01 | 行（エントリ）の数
```

### キーデータ

各キーの型と、そのカラム名を指定する。カラム形式が 0x10 もしくは 0x50 の場合は 5 バイト、0x30 もしくは 0x70 の場合はこの 5 バイトの後に定数値が入る。

```
0x0018 | 54          | 型 ID
0x0019 | 00 00 00 07 | カラム名の文字列オフセット

0x001d | 54          | 型 ID
0x001e | 00 00 00 16 | カラム名の文字列オフセット

...

0x0153 | 5B          | 型 ID
0x0154 | 00 00 02 D2 | カラム名の文字列オフセット
```

型 ID は、カラムの形式とデータ型の情報を持つ（2 つの値の論理 OR をとる）。形式は以下のとおり。

| 形式ID | 内容     |
|--------|----------|
| 0x10   | ゼロ固定 |
| 0x30   | 定数     |
| 0x50   | 通常     |
| 0x70   | 定数     |

データ型は以下のとおり。

| 型ID | 名称    | テーブルデータ上でのサイズ                          |
|------|---------|-----------------------------------------------------|
| 0x00 | UInt8   | 1                                                   |
| 0x01 | Int8    | 1                                                   |
| 0x02 | UInt16  | 2                                                   |
| 0x03 | Int16   | 2                                                   |
| 0x04 | UInt32  | 4                                                   |
| 0x05 | Int32   | 4                                                   |
| 0x06 | UInt64  | 8                                                   |
| 0x07 | Int64   | 8                                                   |
| 0x08 | Float   | 4                                                   |
| 0x09 | Double  | 8                                                   |
| 0x0A | String  | 4（文字列データ内でのオフセット）                   |
| 0x0B | Binary  | 8（バイナリデータ内でのオフセット・バイナリの長さ） |

0x50 系のカラムのバイト数を足し合わせたものと、各行あたりのバイト数は一致する。

### テーブルデータ

キーの順番に、バイナリを詰めてデータが詰められている。ヘッダにある「テーブルデータのオフセット」の位置からはじまる。

```
0x0158 | 00 00 00 00             | 1つめのカラムのデータ（Int32）
0x015c | 00 00 00 00             | 2つめのカラムのデータ（Int32）
...
0x0285 | 00 00 00 00 00 00 00 00 | 最後（64個め）のカラムのデータ（Binary）
```

### 文字列データ

文字列が順に詰められている。Null 文字が終端。最初の文字列はテーブル名になる。それ以外は各データのオフセット情報にしたがう。ヘッダにある「文字列データのオフセット」の位置からはじまる。

```
0x028d | 48 65 61 64 65 72 00                         | Header（テーブル名）
0x0294 | 46 69 6C 65 49 64 65 6E 74 69 66 69 65 72 00 | FileIdentifier（1つめのカラムの名前）
...
0x0596 | 73 6F 6E 67 5F 33 30 32 39 00                | song_3029（35個めのカラム「Name」のデータで指定されている文字列）
```

### バイナリデータ

バイナリが順に詰められている。一定のアラインメントがあるが、こちらも各データのオフセット情報にしたがう。ヘッダにある「バイナリデータのオフセット」の位置からはじまる。

```
0x05b8 | 0E F7 50 41 ... | 6つめのカラム「AcfMd5Hash」のデータで指定されているバイナリ
...
```

なおバイナリデータが @UTF から始まる場合があるが、これは ACB ファイルに格納されているそのバイナリデータが、また ACB ファイルになっているということである。

## AWB ファイルのフォーマット

こちらは AFS2 という形式になっている。数値はリトルエンディアン。

### ヘッダ

```
0x0000 | 41 46 53 32 | 固定（'AFS2'）
0x0004 | 01          | バージョン?
0x0005 | 04          | データサイズの長さ
0x0006 | 02 00       | 固定?
0x0008 | 24 00 00 00 | ファイル数（36）
0x000c | 20 00 00 00 | アラインメント
```

### ファイルのインデックス一覧

インデックスの一覧。後半 1 バイトは別のデータが入っているらしいが、リトルエンディアンとして 16 ビットの数値と解釈しても問題ないよう。

```
0x0010 | 00          | ID
0x0011 | 00          | 不明

0x0012 | 01          | ID
0x0013 | 00          | 不明

...

0x0056 | 23          | ID
0x0057 | 00          | 不明
```

### ファイルの終端位置の一覧

下の例では整数の長さは4バイトになっているが、これはヘッダにある「データサイズの長さ」に従う。ファイル数＋1 個のデータがある。

```
0x0058 | EC 00 00 00 | ヘッダの終端（236）
0x005c | 60 52 01 00 | 1 番目のファイルの終端（86624）
0x0060 | C0 12 02 00 | 2 番目のファイルの終端（135872）
...
```

ファイルの始まる位置はアラインメントの倍数になる。したがって、1 つ前のファイルの終端をアラインメントの倍数に切り上げた位置がファイルの開始位置となる。上の例でいえば、1 番目のファイルは 0x00EC ではなく 0x0100 から始まる。

## HCA ファイルのフォーマット

HCA は音声のエンコードになっているため解析は若干しんどい。数値はビッグエンディアン。

DereTore のほかに HCA を変換できるものとして [libcgss](https://github.com/hozuki/libcgss) や [2ch での実装](http://tamae.2ch.net/test/read.cgi/gameurawaza/1381596257/372) も挙げられる。

### ファイルヘッダ

ヘッダの形式は RIFF に似ている（チャンクが並んでいる形）。各チャンクの最初の識別子は 0x7F7F7F7F との論理積をとった値で比較している。

デコードに必要なチャンクは、ヘッダ、fmt、comp もしくは dec の 3 つのみで、他はなくともデコードすることができる。

#### ヘッダチャンク（8 バイト）

```
0x0000 | C8 C3 C1 00 | 'HCA'
0x0004 | 02 00       | バージョン番号（メジャー・マイナー、この場合 2.0）
0x0006 | 00 60       | データオフセット
```

#### fmt チャンク（16 バイト）

フォーマット情報。

```
0x0008 | E6 ED F4 00 | 'fmt'
0x000C | 02          | チャンネル数
0x000D | 00 AC 44    | サンプリング周波数（44100）
0x0010 | 00 00 13 54 | ブロック数
0x0014 | 00 80       | 先頭の無音ブロック数に 0x400 をかけて 0x80 を加えた値
0x0016 | 01 9A       | 末尾の無音サンプル数
```

どうも無音サンプルまわりの処理は各所の実装では行っていないようである（ブロックデータに含まれていない気がする）。

#### comp チャンク（16 バイト）

圧縮情報。

```
0x0018 | E3 EF ED F0 | 'comp'
0x001C | 02 AA       | ブロックサイズ（0 のときは VBR）
0x001E | 01          | パラメータ 1
0x001F | 0F          | パラメータ 2
...
0x0025 | 00          | パラメータ 8
0x0026 | 00 00       | 予約領域
```

パラメータ3：チャンネルの設定パラメータ。この値でチャンネルをブロック化する。

#### dec チャンク（12 バイト）

展開情報。このチャンクもしくは comp チャンクが必ず含まれる。

```
E4 E5 E3 00 | 'dec'
?? ??       | ブロックサイズ（0 のときは VBR）
??          | パラメータ 1
??          | パラメータ 2
??          |
??          |
?           | パラメータ 3
?           | パラメータ 4
??          |
```

#### vbr チャンク（8 バイト）

可変ビットレート情報。

#### ath チャンク（6 バイト）

ATH テーブル情報。このチャンクがない場合、バージョン 2.0 以上では 1 に、2.0 未満では 0 になる。

```
E1 F4 E8 00 | 'ath'
00 01       | 0 もしくは 1
```

#### loop チャンク（16 バイト）

ループ情報。

```
EC EF EF F0 | 'loop'
?? ?? ?? ?? | 開始ブロックインデックス
?? ?? ?? ?? | 終了ブロックインデックス
?? ??       | ループ回数（0x80 で無限）
02 26       |
```

#### ciph チャンク（6 バイト）

暗号化情報。種類が 0x00 の場合は暗号化なし、0x01 の場合は鍵なし暗号化、0x38 の場合は鍵あり暗号化。

デレステの場合は、鍵は 0x00003657_F27E3B22 である。

```
0x0028 | E3 E9 F0 E8 | 'ciph'
0x002C | 00 38       | 種類
```

#### rva チャンク（8 バイト）

相対ボリューム調節（Relative Volume Adjustment）情報。

```
F2 F6 E1 00 | 'rva'
3F 80 00 00 | ボリューム（float）
```

#### comm チャンク

コメント情報。

```
E3 EF ED ED | 'comm'
??          | コメントの長さ
?? ...      | コメント
```

#### pad チャンク

データがくるまでのパディング。

```
0x002E | F0 E1 E4 00 | 'pad'
0x0032 | 00 00 ...   | ゼロ
```

### データブロック

1 つのブロックは、チャンネル数×1024 のサンプルに変換される。したがって、ビットレートは サンプリング周波数÷1024×ブロックサイズ×8 となる。上の例では 44100/1024*682*8 = 234970.3125 bps = 235 kbps となる（これは 16bit PCM のちょうど 6 分の 1 程度である）。

各ブロックの最初 2 バイトは 0xFFFF である（これは暗号化していても同じである）。

#### 暗号化

暗号化は各バイトごとのストリーム暗号になっており、辞書も変化しない（すなわちランダムアクセスできる）。単純に 256 個の要素の対照表を作っているだけである。なお 0x00 と 0xFF は変化しないように生成している。

なおアルゴリズムとしては線形合同法を用いている。暗号化に使うな。

#### デコード

わからん。

### 巡回冗長検査（CRC）

ファイルのヘッダ領域（データオフセットの直前まで）および各データブロックの最後 2 バイトに検査符号を加えることで実質チェックサムの役割を果たしている。多項式には CRC-16-IBM が用いられている（0x8005）。
